# 定位元素
- 理解盒模型
    + 边框 border
    + 内边距 padding
    + 外边距 margin
垂直方向上的外边距会叠加。较宽的外边距决定两个元素最终离多远
字体单位em是相对单位，与字体相关

如果不设置块级元素的width属性，那么这个属性的默认值是auto，会让宽度扩展到父元素同宽

盒模型结论一：
    - 没有设置宽度的元素始终会扩展到填满父元素的宽度为止，添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。
盒模型结论二：
    - 为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的width属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。

-浮动与清除
    - 浮动影响文字的环绕效果，脱离文档流
    - 父元素收缩，只包裹非浮动元素
        + 方法一 为父元素添加`overflow:hidden`,缺点是不太直观，实际上overflow:hidden真正用途是防止包含元素被超大内容撑大，应用overflow:hidden之后，包含元素依然保持其设定的宽度，而超大的子内容则会被容器剪切掉，还有一个作用就是它能可靠地迫使父元素包含其浮动的子元素。
        + 方法二 同时浮动父元素,父元素`section {border:1px solid blue; float:left; width:100%;} img {float:left;}footer {border:1px solid red; clear:left;}`
        + 方法三 在父元素内容的末尾添加非浮动元素,可以直接在标记中加,也可以通过给父元素添加 clearfix 类来加(当然,样式表中得需要相应的 clearfix 规则)
    三种方法的使用要因地制宜。比如,不能在下拉菜单的顶级元素上应用 overflow:hidden,否则作为其子元素的下拉菜单就不会显示了。因为下拉菜单会显 示在其父元素区域的外部,而这恰恰是 overflow:hidden 所要阻止的。再比如,不能 对已经靠自动外边距居中的元素使用“浮动父元素”技术,否则它就不会再居中,而是根据浮动值浮动到左边或右边了。

- 定位
    + static
    + relative
    + absolute，定位上下文，祖先元素的relative
    + fixed
- 显示属性
    + display
    + visibility  不会删除文档的位置
- 背景
    + 前景色既影响内容也影响边框
